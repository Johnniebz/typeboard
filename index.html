<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>Typeboard — Quick Phrases</title>
  <title>Typeboard — Quick Phrases (Sections + Toggle)</title>
<style>
:root { --pad: 10px; }
html, body { height: 100%; margin: 0; padding: 0; font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; background: #ffffff; color: #111; }
@@ -28,10 +28,46 @@
width: 180px; /* fixed width */
}

    .quickbar { display: flex; gap: 8px; overflow-x: auto; -webkit-overflow-scrolling: touch; padding: 8px; border-top: 1px solid #f6f6f6; border-bottom: 1px solid #f1f1f1; background: #fff; }
    .chip { flex: 0 0 auto; padding: 10px 12px; border-radius: 20px; border: 1px solid #ddd; background: #fafafa; font-weight: 600; font-size: 16px; user-select: none; }
    /* Quick area with two rows: sections + phrases */
    .quickbar { display: flex; flex-direction: column; gap: 6px; padding: 8px; border-top: 1px solid #f6f6f6; border-bottom: 1px solid #f1f1f1; background: #fff; }
    .rowbar {
      display: flex; gap: 8px; overflow-x: auto; -webkit-overflow-scrolling: touch; align-items: center;
    }
    .chip {
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 20px;
      border: 1px solid #ddd;
      background: #fafafa;
      font-weight: 600;
      font-size: 16px;
      user-select: none;
      white-space: nowrap;
    }
.chip:active { background: #f0f0f0; }
    .edit-phrases { margin-left: auto; padding: 8px 12px; border-radius: 10px; border: 1px solid #ddd; background: #fff; font-weight: 600; font-size: 14px; }
    .chip.section { background: #fff; }
    .chip.section.active { background:#111; color:#fff; border-color:#111; }
    .edit-phrases {
      margin-left: auto;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fff;
      font-weight: 600;
      font-size: 14px;
      flex: 0 0 auto;
    }

    /* Sliding phrases row */
    #phrasesWrap {
      overflow: hidden;
      transition: max-height 200ms ease, opacity 200ms ease;
      opacity: 1;
    }
    #phrasesWrap.collapsed {
      max-height: 0;
      opacity: 0;
    }

/* Text area */
textarea { width: 100%; height: 100%; box-sizing: border-box; border: none; outline: none; resize: none; font-size: 28px; line-height: 1.4; -webkit-appearance: none; }
@@ -45,27 +81,23 @@
.btn-sec { background: #f2f2f7; color: #111; }
.note { font-size: 13px; color: #666; margin-bottom: 10px; }

    /* Notes Manager — compact, collapsible, draggable */
    .note-row {
    /* Manage Phrases (sections) — compact, collapsible, draggable */
    .sec-row {
display: grid;
      /* handle | title | delete | chevron */
      grid-template-columns: 28px 1fr auto 24px;
      grid-template-columns: 28px 1fr auto 24px; /* handle | title | delete | chevron */
align-items: center;
gap: 10px;
padding: 10px 8px;
border: 1px solid #eee;
border-radius: 12px;
background: #fff;
      margin-bottom: 8px;
      position: relative;
      margin-bottom: 10px;
touch-action: pan-y;
}
    .note-row.dragging { opacity: 0.9; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .handle { font-size: 18px; line-height: 1; user-select: none; cursor: grab; text-align: center; }
    .sec-row.dragging { opacity: 0.9; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .handle { font-size: 18px; text-align: center; user-select: none; cursor: grab; }
.title { font-weight: 600; font-size: 16px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.chev { font-size: 18px; text-align: center; user-select: none; }

    /* inline delete button (visible even when collapsed) */
.delete-inline {
background: #fff;
border: 1px solid #ffd7d4;
@@ -76,46 +108,39 @@
font-weight: 600;
}
.delete-inline:active { background: #ffeceb; }
    .sec-editor { display: none; grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #eee; }
    .sec-row.expanded .sec-editor { display: block; }
    .row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
    .row input[type="text"], .row textarea { flex: 1; padding: 10px 12px; font-size: 16px; border: 1px solid #ddd; border-radius: 10px; box-sizing: border-box; }
    .row textarea { min-height: 96px; font-size: 15px; line-height: 1.4; }
    .drag-placeholder { height: 58px; border: 2px dashed #cfcfcf; border-radius: 12px; margin: 8px 0; }

    /* Notes Manager (unchanged) */
    .note-row {
      display: grid;
      grid-template-columns: 28px 1fr auto 24px;
      align-items: center;
      gap: 10px;
      padding: 10px 8px;
      border: 1px solid #eee;
      border-radius: 12px;
      background: #fff;
      margin-bottom: 8px;
      position: relative;
      touch-action: pan-y;
    }
    .note-row.dragging { opacity: 0.9; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
.note-editor { display: none; grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #eee; }
.note-row.expanded .note-editor { display: block; }

.note-editor .row { display: flex; gap: 8px; margin-bottom: 8px; }
.note-editor input[type="text"] { flex: 1; padding: 10px 12px; font-size: 15px; border: 1px solid #ddd; border-radius: 10px; }
.note-editor textarea { width: 100%; min-height: 140px; font-size: 15px; line-height: 1.4; border: 1px solid #ddd; border-radius: 10px; padding: 8px 10px; box-sizing: border-box; }
.note-editor .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px; }
    .drag-placeholder { height: 58px; border: 2px dashed #cfcfcf; border-radius: 12px; margin: 8px 0; }

/* Drawing overlay + saved images */
#pad { position: absolute; inset: 8px; width: calc(100% - 16px); height: calc(100% - 16px); touch-action: none; border-radius: 6px; pointer-events: none; }
.drawing-active #pad { pointer-events: auto; }
#drawings img { max-width: 100%; height: auto; display: block; margin: 4px 0; border-radius: 6px; }

    /* === RESTORE ORIGINAL LOOK FOR EDIT PHRASES DIALOG ONLY === */
    #dlg .dlg-body { padding: 12px 16px; }
    #dlg .note { font-size: 13px; color: #666; margin-bottom: 10px; }
    #dlg .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    #dlg .row input[type="text"] {
      flex: 1;
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-sizing: border-box;
    }
    #dlg .btn.btn-sec {
      background: #f2f2f7;
      color: #111;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-weight: 600;
      padding: 10px 12px;
    }
</style>
</head>
<body>
@@ -135,9 +160,19 @@
</div>
</div>

      <div class="quickbar" id="quickbar">
        <!-- chips injected here -->
        <button class="edit-phrases" id="editPhrases" type="button">Edit Phrases</button>
      <!-- quickbar: sections row + phrases row -->
      <div class="quickbar">
        <div class="rowbar" id="sectionsBar">
          <!-- section chips injected here -->
          <button class="edit-phrases" id="editPhrases" type="button">Edit Phrases</button>
        </div>

        <!-- wrapper to animate slide -->
        <div id="phrasesWrap" class="">
          <div class="rowbar" id="phrasesBar">
            <!-- phrase chips for active section injected here -->
          </div>
        </div>
</div>
</div>

@@ -148,22 +183,21 @@
</div>
</div>

  <!-- Phrases dialog -->
  <dialog id="dlg">
    <div class="dlg-head">Quick Phrases</div>
  <!-- Manage PHRASES (sections) dialog -->
  <dialog id="phrasesDlg">
    <div class="dlg-head">Quick Phrases — Sections</div>
<div class="dlg-body">
      <div class="note">Tap to edit your most-used phrases. They’ll be saved on this device.</div>
      <div id="rows"></div>
      <button class="btn btn-sec" id="addRow" type="button">+ Add phrase</button>
      <div class="note">Create sections (e.g., <b>Hospital</b>, <b>Home</b>, <b>Core</b>), then add phrases separated by commas or new lines. Drag ☰ to reorder sections.</div>
      <div id="sectionsList"></div>
      <button class="btn btn-sec" id="addSection" type="button">+ Add section</button>
</div>
<div class="dlg-foot">
      <button class="btn btn-sec" id="reset" type="button">Reset</button>
      <button class="btn btn-sec" id="cancel" type="button">Cancel</button>
      <button class="btn btn-clear" id="save" type="button">Save</button>
      <button class="btn btn-sec" id="phrasesCancel" type="button">Close</button>
      <button class="btn btn-clear" id="phrasesSave" type="button">Save Changes</button>
</div>
</dialog>

  <!-- Notes Manager dialog (compact + draggable) -->
  <!-- Notes Manager dialog -->
<dialog id="notesDlg">
<div class="dlg-head">Notes</div>
<div class="dlg-body">
@@ -178,77 +212,359 @@
</dialog>

<script>
    const board = document.getElementById('board');
    const clearBtn = document.getElementById('clear');
    const bigger = document.getElementById('bigger');
    const smaller = document.getElementById('smaller');
    const quickbar = document.getElementById('quickbar');
    const editBtn = document.getElementById('editPhrases');
    const dlg = document.getElementById('dlg');
    const rows = document.getElementById('rows');
    const addRow = document.getElementById('addRow');
    const cancel = document.getElementById('cancel');
    const save = document.getElementById('save');
    const reset = document.getElementById('reset');

    /* -------- Phrases (existing) -------- */
    const DEFAULTS = ["Sí","No","No lo sé","Gracias"];

    function loadPhrases(){ try{ const raw=localStorage.getItem('typeboard.phrases'); const arr=raw?JSON.parse(raw):DEFAULTS.slice(); return Array.isArray(arr)&&arr.length?arr.slice(0,20):DEFAULTS.slice(); }catch{ return DEFAULTS.slice(); } }
    function savePhrases(list){ localStorage.setItem('typeboard.phrases', JSON.stringify(list.filter(Boolean))); }

    function renderChips(){
      const list = loadPhrases();
      quickbar.querySelectorAll('.chip').forEach(c=>c.remove());
      const edit = editBtn;
      list.forEach((txt, idx)=>{
        const chip=document.createElement('button');
        chip.type='button'; chip.className='chip'; chip.textContent=txt;
        chip.addEventListener('click',()=>{
    /* ===============================
       ELEMENTS (no duplicates)
    =============================== */
    const board          = document.getElementById('board');
    const clearBtn       = document.getElementById('clear');
    const bigger         = document.getElementById('bigger');
    const smaller        = document.getElementById('smaller');
    const sectionsBar    = document.getElementById('sectionsBar');
    const phrasesWrap    = document.getElementById('phrasesWrap');
    const phrasesBar     = document.getElementById('phrasesBar');
    const editBtn        = document.getElementById('editPhrases');

    // Phrases dialog
    const phrasesDlg     = document.getElementById('phrasesDlg');
    const sectionsList   = document.getElementById('sectionsList');
    const addSectionBtn  = document.getElementById('addSection');
    const phrasesCancel  = document.getElementById('phrasesCancel');
    const phrasesSave    = document.getElementById('phrasesSave');

    // Notes dialog
    const NOTES_KEY       = 'typeboard.notes';
    const NOTES_TITLE_MAX = 40;
    const notesDlg        = document.getElementById('notesDlg');
    const notesList       = document.getElementById('notesList');
    const addNoteBtn      = document.getElementById('addNote');
    const notesCancel     = document.getElementById('notesCancel');
    const notesSaveBtn    = document.getElementById('notesSave');
    const notesPicker     = document.getElementById('notesPicker');
    const manageNotesBtn  = document.getElementById('manageNotes');

    /* ===============================
       QUICK PHRASES — WITH SECTIONS
    =============================== */
    const PHRASES_V2_KEY = 'typeboard.phrases.v2';
    const PHRASES_V1_KEY = 'typeboard.phrases'; // old simple list

    const DEFAULT_SECTIONS = [
      { title: 'Core',     phrases: ['Sí','No','Gracias','Por favor','Perfecto','No lo sé'] },
      { title: 'Hospital', phrases: ['Gasas','Médico','Dolor','Comida','Enfermera','Lavabo'] },
      { title: 'Tiempo',   phrases: ['Hoy','Mañana','Ahora','Luego'] }
    ];

    function loadSections() {
      try {
        const raw = localStorage.getItem(PHRASES_V2_KEY);
        if (raw) {
          const obj = JSON.parse(raw);
          if (Array.isArray(obj?.sections)) return sanitizeSections(obj.sections);
        }
      } catch {}
      try {
        const raw1 = localStorage.getItem(PHRASES_V1_KEY);
        if (raw1) {
          const list = JSON.parse(raw1);
          if (Array.isArray(list) && list.length) {
            const migrated = [{ title: 'Phrases', phrases: list.filter(Boolean) }];
            saveSections(migrated);
            return sanitizeSections(migrated);
          }
        }
      } catch {}
      return DEFAULT_SECTIONS.slice();
    }
    function sanitizeSections(arr) {
      return arr.map(s => ({
        title: (s.title || '').toString().trim() || 'Untitled',
        phrases: Array.isArray(s.phrases) ? s.phrases.map(p => p.toString()).filter(Boolean) : []
      })).filter(sec => sec.phrases.length || sec.title);
    }
    function saveSections(secs) {
      localStorage.setItem(PHRASES_V2_KEY, JSON.stringify({ sections: secs }));
    }

    let SECTIONS = loadSections();
    // Only one section open at a time; null = collapsed (no phrases visible)
    let activeSection = null;

    function renderSectionsBar() {
      // remove old section chips (keep Edit button at the end)
      sectionsBar.querySelectorAll('.chip.section').forEach(el => el.remove());

      SECTIONS.forEach((sec, idx) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        const isActive = activeSection === idx;
        chip.className = 'chip section' + (isActive ? ' active' : '');
        chip.textContent = sec.title || 'Untitled';
        chip.addEventListener('click', () => toggleSection(idx));

        // Long-press quick rename/delete
        let timer;
        chip.addEventListener('touchstart', () => {
          timer = setTimeout(() => {
            const action = prompt('Edit section title or type DELETE to remove:', sec.title);
            if (action === null) return;
            if (action.trim().toUpperCase() === 'DELETE') {
              if (confirm(`Delete section "${sec.title}"?`)) {
                SECTIONS.splice(idx, 1);
                if (activeSection === idx) activeSection = null;
                else if (typeof activeSection === 'number' && idx < activeSection) activeSection -= 1;
                saveSections(SECTIONS);
                renderSectionsBar(); renderPhrasesBar();
              }
            } else {
              const newTitle = action.trim();
              if (newTitle) {
                sec.title = newTitle;
                saveSections(SECTIONS);
                renderSectionsBar();
              }
            }
          }, 600);
        }, {passive:true});
        chip.addEventListener('touchend', () => clearTimeout(timer), {passive:true});
        chip.addEventListener('touchmove', () => clearTimeout(timer), {passive:true});

        sectionsBar.insertBefore(chip, editBtn);
      });
    }

    function renderPhrasesBar() {
      phrasesBar.innerHTML = '';
      if (activeSection === null || !SECTIONS.length) {
        collapsePhrases(true);
        return;
      }
      const sec = SECTIONS[activeSection] || { phrases: [] };
      sec.phrases.forEach((txt, idx) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = txt;

        chip.addEventListener('click', () => {
const needsSpace = board.value && !board.value.endsWith(' ');
board.value = (board.value || '') + (needsSpace ? ' ' : '') + txt;
board.focus();
board.selectionStart = board.selectionEnd = board.value.length;
});
        chip.addEventListener('dblclick',(e)=>{ e.preventDefault(); board.value = txt; board.focus(); });

        chip.addEventListener('dblclick', (e) => {
          e.preventDefault();
          board.value = txt;
          board.focus();
        });

        // Long-press edit/delete
let pressTimer;
        chip.addEventListener('touchstart',()=>{ pressTimer=setTimeout(()=>{ const newTxt=prompt('Edit phrase:', txt); if(newTxt!==null){ const list2=loadPhrases(); list2[idx]=newTxt.trim(); savePhrases(list2); renderChips(); } },550); });
        chip.addEventListener('touchend',()=>clearTimeout(pressTimer));
        chip.addEventListener('touchmove',()=>clearTimeout(pressTimer));
        quickbar.insertBefore(chip, edit);
        chip.addEventListener('touchstart', () => {
          pressTimer = setTimeout(() => {
            const action = prompt('Edit phrase text or type DELETE to remove:', txt);
            if (action === null) return;
            if (action.trim().toUpperCase() === 'DELETE') {
              sec.phrases.splice(idx, 1);
              saveSections(SECTIONS);
              renderPhrasesBar();
            } else {
              const newTxt = action.trim();
              if (newTxt) {
                sec.phrases[idx] = newTxt;
                saveSections(SECTIONS);
                renderPhrasesBar();
              }
            }
          }, 550);
        }, {passive:true});
        chip.addEventListener('touchend', () => clearTimeout(pressTimer), {passive:true});
        chip.addEventListener('touchmove', () => clearTimeout(pressTimer), {passive:true});

        phrasesBar.appendChild(chip);
});

      // expand with animation
      collapsePhrases(false);
}

    function openEditor(){ rows.innerHTML=''; const list=loadPhrases(); list.forEach(txt=>addEditorRow(txt)); if(list.length===0) addEditorRow(''); dlg.showModal(); }
    function addEditorRow(val=''){ const row=document.createElement('div'); row.className='row'; const input=document.createElement('input'); input.type='text'; input.placeholder='Phrase'; input.value=val; const del=document.createElement('button'); del.type='button'; del.textContent='Delete'; del.className='btn btn-sec'; del.addEventListener('click',()=>row.remove()); row.appendChild(input); row.appendChild(del); rows.appendChild(row); }
    function toggleSection(idx) {
      // If tapping same -> collapse; else open that one
      if (activeSection === idx) {
        activeSection = null;
        renderSectionsBar();
        renderPhrasesBar();
      } else {
        activeSection = idx;
        renderSectionsBar();
        renderPhrasesBar();
      }
    }

    window.addEventListener('load', ()=>{ renderChips(); renderNotesPicker(); board.focus(); sizeCanvas(); });
    // Slide animation helpers
    function collapsePhrases(shouldCollapse) {
      if (shouldCollapse) {
        phrasesWrap.style.maxHeight = phrasesWrap.scrollHeight + 'px'; // set current
        // force reflow then collapse
        void phrasesWrap.offsetHeight;
        phrasesWrap.classList.add('collapsed');
        phrasesWrap.style.maxHeight = '0px';
      } else {
        phrasesWrap.classList.remove('collapsed');
        // set to content height then clear after transition
        phrasesWrap.style.maxHeight = phrasesBar.scrollHeight + 'px';
        // after transition ends, set to 'none' so future content changes aren't clipped
        phrasesWrap.addEventListener('transitionend', function tidy(e){
          if (e.propertyName === 'max-height') {
            phrasesWrap.style.maxHeight = 'none';
            phrasesWrap.removeEventListener('transitionend', tidy);
          }
        });
      }
    }

    /* CLEAR everything */
    clearBtn.addEventListener('click', ()=>{ board.value=''; drawings.innerHTML=''; const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); dirty=false; board.focus(); });
    // Manage dialog (sections editor)
    function openPhrasesManager() {
      sectionsList.innerHTML = '';
      SECTIONS.forEach(sec => addSectionRow(sec.title, sec.phrases.join('\n'), false));
      phrasesDlg.showModal();
    }

    function getSize(){ const s=window.getComputedStyle(board).fontSize; return parseFloat(s||'28'); }
    bigger.addEventListener('click', ()=>{ board.style.fontSize = Math.min(getSize()+4, 72)+'px'; board.focus(); });
    smaller.addEventListener('click', ()=>{ board.style.fontSize = Math.max(getSize()-4, 14)+'px'; board.focus(); });
    function addSectionRow(title = '', phrasesText = '', autoExpand = true) {
      const row = document.createElement('div'); row.className = 'sec-row';

    editBtn.addEventListener('click', openEditor);
    addRow.addEventListener('click', ()=>addEditorRow(''));
    cancel.addEventListener('click', ()=>dlg.close());
    reset.addEventListener('click', ()=>{ if(confirm('Reset phrases to defaults?')){ savePhrases(DEFAULTS.slice()); renderChips(); dlg.close(); } });
    save.addEventListener('click', ()=>{ const inputs=[...rows.querySelectorAll('input[type="text"]')]; const list=inputs.map(i=>i.value.trim()).filter(Boolean); savePhrases(list); renderChips(); dlg.close(); });
      const handle = document.createElement('div'); handle.className = 'handle'; handle.textContent = '☰'; handle.title = 'Drag to reorder';
      const titleSpan = document.createElement('div'); titleSpan.className = 'title'; titleSpan.textContent = title || 'Untitled';
      const delInline = document.createElement('button'); delInline.type = 'button'; delInline.className = 'delete-inline'; delInline.textContent = 'Delete';
      const chev = document.createElement('div'); chev.className = 'chev'; chev.textContent = '›';

    document.addEventListener('keydown',(e)=>{ if((e.metaKey||e.ctrlKey) && (e.key==='Backspace'||e.key==='Delete')){ e.preventDefault(); board.value=''; drawings.innerHTML=''; const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); dirty=false; } });
      const editor = document.createElement('div'); editor.className = 'sec-editor';
      editor.innerHTML = `
        <div class="row">
          <input type="text" class="title-input" placeholder="Section title" value="">
        </div>
        <div class="row">
          <textarea class="phrases-input" placeholder="Phrases (comma or new line separated)"></textarea>
        </div>
        <div class="row" style="justify-content:flex-end; color:#666; font-size:13px;">
          Changes apply when you press “Save Changes”.
        </div>
      `;

      row.append(handle, titleSpan, delInline, chev, editor);
      sectionsList.appendChild(row);

    /* -------- Notes (compact + draggable, inline delete only) -------- */
    const NOTES_KEY='typeboard.notes', NOTES_TITLE_MAX=40;
    const notesDlg=document.getElementById('notesDlg');
    const notesList=document.getElementById('notesList');
    const addNoteBtn=document.getElementById('addNote');
    const notesCancel=document.getElementById('notesCancel');
    const notesSave=document.getElementById('notesSave');
    const notesPicker=document.getElementById('notesPicker');
    const manageNotesBtn=document.getElementById('manageNotes');
      const titleInput = editor.querySelector('.title-input');
      const phrasesInput = editor.querySelector('.phrases-input');
      titleInput.value = title;
      phrasesInput.value = phrasesText;

      function toggleExpand() {
        const exp = row.classList.toggle('expanded');
        chev.textContent = exp ? '▾' : '›';
        if (exp) { titleInput.focus(); titleInput.select(); }
      }
      titleSpan.addEventListener('click', toggleExpand);
      chev.addEventListener('click', toggleExpand);

      titleInput.addEventListener('input', (e) => {
        const t = e.target.value.trim();
        titleSpan.textContent = t || 'Untitled';
      });

      delInline.addEventListener('click', () => {
        if (confirm('Delete this section?')) row.remove();
      });

      enableSectionDrag(row, handle);

      if (autoExpand) {
        row.classList.add('expanded');
        chev.textContent = '▾';
        setTimeout(() => { titleInput.focus(); titleInput.select(); }, 0);
      }
    }

    function enableSectionDrag(row, handle) {
      let dragging=false, startY=0, currentY=0, placeholder=null;

      const onDown = (e) => {
        e.preventDefault();
        dragging = true; startY = getY(e);
        row.classList.add('dragging');
        placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.style.height = row.getBoundingClientRect().height + 'px';
        sectionsList.insertBefore(placeholder, row.nextSibling);
        row.style.position='relative'; row.style.zIndex='1'; row.style.transform='translateY(0px)';

        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', onUp, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', onUp, {passive:false});
        window.addEventListener('mousemove', onMove, {passive:false});
        window.addEventListener('mouseup', onUp, {passive:false});
      };

      const onMove = (e) => {
        if(!dragging) return; e.preventDefault();
        currentY = getY(e);
        const dy = currentY - startY;
        row.style.transform = `translateY(${dy}px)`;
        const rowsArr = [...sectionsList.querySelectorAll('.sec-row')].filter(el => el !== row);
        let placed = false;
        for (const r of rowsArr) {
          const rect = r.getBoundingClientRect();
          if (currentY < rect.top + rect.height/2) { sectionsList.insertBefore(placeholder, r); placed = true; break; }
        }
        if (!placed) sectionsList.appendChild(placeholder);
      };

      const onUp = () => {
        if(!dragging) return; dragging=false;
        row.classList.remove('dragging'); row.style.position=''; row.style.zIndex=''; row.style.transform='';
        if (placeholder) { sectionsList.insertBefore(row, placeholder); placeholder.remove(); placeholder = null; }
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      };

      const getY = (e) => e.touches?.[0]?.clientY ?? e.changedTouches?.[0]?.clientY ?? e.clientY ?? 0;

      handle.addEventListener('pointerdown', onDown);
      handle.addEventListener('touchstart', onDown, {passive:false});
      handle.addEventListener('mousedown', onDown);
    }

    function collectSectionsFromDialog() {
      const rows = [...sectionsList.querySelectorAll('.sec-row')];
      const out = rows.map(r => {
        const t = r.querySelector('.title-input')?.value.trim() || r.querySelector('.title')?.textContent || 'Untitled';
        const raw = r.querySelector('.phrases-input')?.value || '';
        const phrases = raw.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
        return { title: t, phrases };
      });
      return sanitizeSections(out);
    }

    editBtn.addEventListener('click', openPhrasesManager);
    addSectionBtn.addEventListener('click', () => addSectionRow('', '', true));
    phrasesCancel.addEventListener('click', () => phrasesDlg.close());
    phrasesSave.addEventListener('click', () => {
      SECTIONS = collectSectionsFromDialog();
      saveSections(SECTIONS);
      // keep state: if activeSection is out of range, collapse
      if (typeof activeSection === 'number' && activeSection >= SECTIONS.length) activeSection = null;
      renderSectionsBar(); renderPhrasesBar();
      phrasesDlg.close();
    });

    /* ===============================
       NOTES
    =============================== */
function loadNotes(){ try{ const raw=localStorage.getItem(NOTES_KEY); const arr=raw?JSON.parse(raw):[]; return Array.isArray(arr)?arr:[]; }catch{ return []; } }
function saveNotes(arr){ localStorage.setItem(NOTES_KEY, JSON.stringify(arr)); }
function renderNotesPicker(){ const arr=loadNotes(); notesPicker.innerHTML='<option value="">Notes ▾</option>'; arr.forEach((n,i)=>{ const opt=document.createElement('option'); opt.value=String(i); opt.textContent=n.title||`Note ${i+1}`; notesPicker.appendChild(opt); }); }
@@ -270,15 +586,10 @@

function addNoteRow(title='', body='', autoExpand=false){
const row=document.createElement('div'); row.className='note-row'; row.setAttribute('data-title',title);

const handle=document.createElement('div'); handle.className='handle'; handle.textContent='☰'; handle.title='Drag to reorder';
const titleSpan=document.createElement('div'); titleSpan.className='title'; titleSpan.textContent=title||'Untitled';

      // inline delete (always visible)
const delInline=document.createElement('button'); delInline.type='button'; delInline.className='delete-inline'; delInline.textContent='Delete';

const chev=document.createElement('div'); chev.className='chev'; chev.textContent='›';

const editor=document.createElement('div'); editor.className='note-editor';
editor.innerHTML = `
       <div class="row">
@@ -287,10 +598,8 @@
       <textarea class="body-input" placeholder="Write your note text here..."></textarea>
       <div class="actions"><span style="font-size:13px;color:#666;">Changes are saved with “Save Changes”.</span></div>
     `;

row.append(handle, titleSpan, delInline, chev, editor);
notesList.appendChild(row);

const titleInput=editor.querySelector('.title-input');
const bodyInput=editor.querySelector('.body-input');
titleInput.value = title.slice(0,NOTES_TITLE_MAX);
@@ -300,10 +609,7 @@
titleSpan.addEventListener('click', toggleExpand);
chev.addEventListener('click', toggleExpand);

      // live title preview
titleInput.addEventListener('input', (e)=>{ const t=e.target.value.trim(); titleSpan.textContent=t||'Untitled'; });

      // delete action (inline only)
const doDelete = () => { if (confirm('Delete this note?')) row.remove(); };
delInline.addEventListener('click', doDelete);

@@ -317,22 +623,8 @@
editor.style.gridColumn = '1 / -1';
}

    addNoteBtn.addEventListener('click', ()=> addNoteRow('', '', true));
    notesCancel.addEventListener('click', ()=> notesDlg.close());
    notesSave.addEventListener('click', ()=>{
      const rowsDom=[...notesList.querySelectorAll('.note-row')];
      const arr=rowsDom.map(r=>{
        const t=(r.querySelector('.title-input')?.value.trim() || r.getAttribute('data-title') || '').slice(0,NOTES_TITLE_MAX);
        const b=r.querySelector('.body-input')?.value || '';
        return { title: t || 'Untitled', body: b };
      });
      saveNotes(arr); renderNotesPicker(); notesDlg.close();
    });

    /* Drag & drop for rows (pointer/touch/mouse) */
function enableRowDrag(row, handle){
let dragging=false, startY=0, currentY=0, placeholder=null;

const onDown=(e)=>{
e.preventDefault();
dragging=true; startY=getY(e);
@@ -348,7 +640,6 @@
window.addEventListener('mousemove', onMove, {passive:false});
window.addEventListener('mouseup', onUp, {passive:false});
};

const onMove=(e)=>{
if(!dragging) return; e.preventDefault();
currentY=getY(e); const dy=currentY-startY; row.style.transform=`translateY(${dy}px)`;
@@ -360,7 +651,6 @@
}
if(!placed) notesList.appendChild(placeholder);
};

const onUp=()=>{
if(!dragging) return; dragging=false;
row.classList.remove('dragging'); row.style.position=''; row.style.zIndex=''; row.style.transform='';
@@ -373,39 +663,126 @@
window.removeEventListener('mousemove', onMove);
window.removeEventListener('mouseup', onUp);
};

const getY=(e)=> e.touches?.[0]?.clientY ?? e.changedTouches?.[0]?.clientY ?? e.clientY ?? 0;

handle.addEventListener('pointerdown', onDown);
handle.addEventListener('touchstart', onDown, {passive:false});
handle.addEventListener('mousedown', onDown);
}

    /* helper: insert text at cursor in textarea */
    function insertTextAtCursorTextarea(ta, text){
      const start=ta.selectionStart ?? ta.value.length, end=ta.selectionEnd ?? ta.value.length;
      const before=ta.value.slice(0,start), after=ta.value.slice(end);
      ta.value = before + text + after;
      const pos = (before + text).length; ta.selectionStart = ta.selectionEnd = pos;
    }
    function getY(e){ return e.touches?.[0]?.clientY ?? e.changedTouches?.[0]?.clientY ?? e.clientY ?? 0; }

    /* ===============================
       CLEAR / FONT SIZE / LOAD
    =============================== */
    window.addEventListener('load', ()=>{ renderSectionsBar(); renderPhrasesBar(); renderNotesPicker(); board.focus(); sizeCanvas(); });

    clearBtn.addEventListener('click', ()=>{ board.value=''; drawings.innerHTML=''; const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); dirty=false; board.focus(); });

    function getSize(){ const s=window.getComputedStyle(board).fontSize; return parseFloat(s||'28'); }
    bigger.addEventListener('click', ()=>{ board.style.fontSize = Math.min(getSize()+4, 72)+'px'; board.focus(); });
    smaller.addEventListener('click', ()=>{ board.style.fontSize = Math.max(getSize()-4, 14)+'px'; board.focus(); });

    document.addEventListener('keydown',(e)=>{ if((e.metaKey||e.ctrlKey) && (e.key==='Backspace'||e.key==='Delete')){ e.preventDefault(); board.value=''; drawings.innerHTML=''; const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); dirty=false; } });

    /* ===============================
       OPEN NOTES / SAVE NOTES
    =============================== */
    manageNotesBtn.addEventListener('click', openNotesManager);
    addNoteBtn.addEventListener('click', ()=> addNoteRow('', '', true));
    notesCancel.addEventListener('click', ()=> notesDlg.close());
    notesSaveBtn.addEventListener('click', ()=>{
      const rowsDom=[...notesList.querySelectorAll('.note-row')];
      const arr=rowsDom.map(r=>{
        const t=(r.querySelector('.title-input')?.value.trim() || r.getAttribute('data-title') || '').slice(0,NOTES_TITLE_MAX);
        const b=r.querySelector('.body-input')?.value || '';
        return { title: t || 'Untitled', body: b };
      });
      saveNotes(arr); renderNotesPicker(); notesDlg.close();
    });

    /* -------- Drawing (unchanged) -------- */
    const drawings=document.getElementById('drawings');
    const pad=document.getElementById('pad');
    const ctx=pad.getContext('2d');
    const toggleDraw=document.getElementById('toggleDraw');
    /* ===============================
       DRAWING
    =============================== */
    const drawings   = document.getElementById('drawings');
    const pad        = document.getElementById('pad');
    const ctx        = pad.getContext('2d');
    const toggleDraw = document.getElementById('toggleDraw');
let drawing=false, drawActive=false, dirty=false;
let lastX=0, lastY=0, dpr=1;

    function sizeCanvas(){ const rect=pad.getBoundingClientRect(); dpr=window.devicePixelRatio||1; ctx.setTransform(1,0,0,1,0,0); pad.width=Math.max(1, Math.floor(rect.width*dpr)); pad.height=Math.max(1, Math.floor(rect.height*dpr)); ctx.scale(dpr,dpr); ctx.clearRect(0,0, rect.width, rect.height); dirty=false; }
    function sizeCanvas(){
      const rect=pad.getBoundingClientRect();
      dpr=window.devicePixelRatio||1;
      ctx.setTransform(1,0,0,1,0,0);
      pad.width=Math.max(1, Math.floor(rect.width*dpr));
      pad.height=Math.max(1, Math.floor(rect.height*dpr));
      ctx.scale(dpr,dpr);
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty=false;
    }
function startDraw(x,y){ drawing=true; lastX=x; lastY=y; }
function moveDraw(x,y){ if(!drawing) return; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#111'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y; dirty=true; }
function endDraw(){ drawing=false; }
function getPoint(e){ const rect=pad.getBoundingClientRect(); if(e.touches&&e.touches.length){ const t=e.touches[0]; return {x:t.clientX-rect.left, y:t.clientY-rect.top}; } return {x:e.clientX-rect.left, y:e.clientY-rect.top}; }
    function getVerticalContentBounds(){ const w=pad.width, h=pad.height; if(!dirty||!w||!h) return null; try{ const data=ctx.getImageData(0,0,w,h).data; let topFound=false, bottomFound=false, top=0, bottom=h-1; for(let y=0;y<h;y++){ const row=y*w*4; for(let x=0;x<w;x++){ if(data[row+x*4+3]!==0){ top=y; topFound=true; break; } } if(topFound) break; } if(!topFound) return null; for(let y=h-1;y>=0;y--){ const row=y*w*4; for(let x=0;x<w;x++){ if(data[row+x*4+3]!==0){ bottom=y; bottomFound=true; break; } } if(bottomFound) break; } return {top,bottom}; }catch{ return null; } }
    function saveDrawingIfAny(){ if(!dirty) return; const w=pad.width,h=pad.height; const b=getVerticalContentBounds(); let sy=0,sh=h; const cssDpr=window.devicePixelRatio||1; const margin=Math.round(cssDpr*2); if(b){ sy=Math.max(0,b.top-margin); const bt=Math.min(h-1,b.bottom+margin); sh=Math.max(1, bt-sy+1); } const off=document.createElement('canvas'); off.width=w; off.height=sh; const offCtx=off.getContext('2d'); offCtx.drawImage(pad,0,sy,w,sh,0,0,w,sh); const img=new Image(); img.src=off.toDataURL('image/png'); drawings.appendChild(img); const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0, rect.width, rect.height); dirty=false; board.focus(); }

    toggleDraw.addEventListener('click', ()=>{ saveDrawingIfAny(); drawActive=!drawActive; toggleDraw.textContent = drawActive ? 'Draw: On' : 'Draw: Off'; toggleDraw.setAttribute('aria-pressed', String(drawActive)); document.body.classList.toggle('drawing-active', drawActive); if(drawActive){ board.blur(); sizeCanvas(); } else { board.focus(); } });
    function getVerticalContentBounds(){
      const w=pad.width, h=pad.height;
      if(!dirty||!w||!h) return null;
      try{
        const data=ctx.getImageData(0,0,w,h).data;
        let topFound=false, bottomFound=false, top=0, bottom=h-1;
        for(let y=0;y<h;y++){
          const row=y*w*4;
          for(let x=0;x<w;x++){
            if(data[row+x*4+3]!==0){ top=y; topFound=true; break; }
          }
          if(topFound) break;
        }
        if(!topFound) return null;
        for(let y=h-1;y>=0;y--){
          const row=y*w*4;
          for(let x=0;x<w;x++){
            if(data[row+x*4+3]!==0){ bottom=y; bottomFound=true; break; }
          }
          if(bottomFound) break;
        }
        return {top,bottom};
      }catch{ return null; }
    }
    function saveDrawingIfAny(){
      if(!dirty) return;
      const w=pad.width,h=pad.height;
      const b=getVerticalContentBounds();
      let sy=0,sh=h;
      const cssDpr=window.devicePixelRatio||1;
      const margin=Math.round(cssDpr*2);
      if(b){
        sy=Math.max(0,b.top-margin);
        const bt=Math.min(h-1,b.bottom+margin);
        sh=Math.max(1, bt-sy+1);
      }
      const off=document.createElement('canvas');
      off.width=w; off.height=sh;
      const offCtx=off.getContext('2d');
      offCtx.drawImage(pad,0,sy,w,sh,0,0,w,sh);
      const img=new Image();
      img.src=off.toDataURL('image/png');
      drawings.appendChild(img);
      const rect=pad.getBoundingClientRect();
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty=false;
      board.focus();
    }

    toggleDraw.addEventListener('click', ()=>{
      saveDrawingIfAny();
      drawActive=!drawActive;
      toggleDraw.textContent = drawActive ? 'Draw: On' : 'Draw: Off';
      toggleDraw.setAttribute('aria-pressed', String(drawActive));
      document.body.classList.toggle('drawing-active', drawActive);
      if(drawActive){ board.blur(); sizeCanvas(); } else { board.focus(); }
    });

pad.addEventListener('touchstart',(e)=>{ if(!drawActive) return; e.preventDefault(); const p=getPoint(e); startDraw(p.x,p.y); });
pad.addEventListener('touchmove',(e)=>{ if(!drawActive) return; e.preventDefault(); const p=getPoint(e); moveDraw(p.x,p.y); });
