<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>Typeboard — Quick Phrases (Sections + Toggle)</title>
  <style>
    :root { --pad: 10px; }
    html, body { height: 100%; margin: 0; padding: 0; font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; background: #ffffff; color: #111; }
   
    /* Prefer dynamic viewport height on iOS to avoid jump when bars collapse */
.wrap { height: 100dvh; display: flex; flex-direction: column; }

/* Fall back to svh if dvh is not supported */
@supports not (height: 100dvh) {
  .wrap { height: 100svh; }
}

/* Small-screen/iPhone adjustments */
@media (max-width: 430px) {
  .bar {
    gap: 6px;
    flex-wrap: wrap; /* allow stacking */
  }
  .btn { 
    padding: 8px 10px; 
    font-size: 16px; 
    border-radius: 9px;
  }
  .btn-large { font-size: 16px; }
  .notes-controls { 
    width: 100%; 
    gap: 6px; 
    flex-wrap: wrap; 
    justify-content: flex-end;
  }
  .notes-picker {
    width: min(55vw, 180px); /* shrink on iPhone */
  }
  textarea { 
    font-size: 24px; /* slightly smaller default on small screens */
  }
}


    /* Sticky header (bar + quickbar) */
    .header { position: sticky; top: 0; z-index: 10; background: #fff; border-bottom: 1px solid #eee; }
    .bar { padding: 8px; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .btn { padding: 10px 14px; font-size: 18px; font-weight: 600; border: none; border-radius: 10px; cursor: pointer; -webkit-tap-highlight-color: rgba(0,0,0,0); }
    .btn-clear { background: #ff3b30; color: #fff; font-weight: 700; }
    .btn-large { background: #f2f2f7; color: #111; }

    /* Notes controls */
    .notes-controls { display: flex; gap: 8px; align-items: center; }
    .notes-picker {
      appearance: none; -webkit-appearance: none;
      padding: 10px 12px; font-size: 16px;
      border-radius: 10px; border: 1px solid #ddd; background: #fff;
      width: 180px; /* fixed width */
    }

    /* Quick area with two rows: sections + phrases */
    .quickbar { display: flex; flex-direction: column; gap: 6px; padding: 8px; border-top: 1px solid #f6f6f6; border-bottom: 1px solid #f1f1f1; background: #fff; }
    .rowbar {
      display: flex; gap: 8px; overflow-x: auto; -webkit-overflow-scrolling: touch; align-items: center;
    }
    .chip {
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 20px;
      border: 1px solid #ddd;
      background: #fafafa;
      font-weight: 600;
      font-size: 16px;
      user-select: none;
      white-space: nowrap;
    }
    .chip:active { background: #f0f0f0; }
    .chip.section { background: #fff; }
    .chip.section.active { background:#111; color:#fff; border-color:#111; }
    .edit-phrases {
      margin-left: auto;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fff;
      font-weight: 600;
      font-size: 14px;
      flex: 0 0 auto;
    }

    /* Sliding phrases row */
    #phrasesWrap {
      overflow: hidden;
      transition: max-height 200ms ease, opacity 200ms ease;
      opacity: 1;
    }
    #phrasesWrap.collapsed {
      max-height: 0;
      opacity: 0;
    }

    /* Text area */
    textarea { width: 100%; height: 100%; box-sizing: border-box; border: none; outline: none; resize: none; font-size: 28px; line-height: 1.4; -webkit-appearance: none; }

    /* Dialog base */
    dialog::backdrop { background: rgba(0,0,0,0.35); }
    dialog { border: none; border-radius: 16px; max-width: 640px; width: calc(100% - 32px); padding: 0; overflow: hidden; }
    .dlg-head { padding: 14px 16px; font-weight: 700; border-bottom: 1px solid #eee; background: #fafafa; }
    .dlg-body { padding: 12px 16px; max-height: 60vh; overflow: auto; }
    .dlg-foot { display: flex; gap: 10px; padding: 12px 16px; border-top: 1px solid #eee; justify-content: flex-end; background: #fafafa; }
    .btn-sec { background: #f2f2f7; color: #111; }
    .note { font-size: 13px; color: #666; margin-bottom: 10px; }

    /* Manage Phrases (sections) — compact, collapsible, draggable */
    .sec-row {
      display: grid;
      grid-template-columns: 28px 1fr auto 24px; /* handle | title | delete | chevron */
      align-items: center;
      gap: 10px;
      padding: 10px 8px;
      border: 1px solid #eee;
      border-radius: 12px;
      background: #fff;
      margin-bottom: 10px;
      touch-action: pan-y;
    }
    .sec-row.dragging { opacity: 0.9; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .handle { font-size: 18px; text-align: center; user-select: none; cursor: grab; }
    .title { font-weight: 600; font-size: 16px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .chev { font-size: 18px; text-align: center; user-select: none; }
    .delete-inline {
      background: #fff;
      border: 1px solid #ffd7d4;
      color: #ff3b30;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 14px;
      font-weight: 600;
    }
    .delete-inline:active { background: #ffeceb; }
    .sec-editor { display: none; grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #eee; }
    .sec-row.expanded .sec-editor { display: block; }
    .row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
    .row input[type="text"], .row textarea { flex: 1; padding: 10px 12px; font-size: 16px; border: 1px solid #ddd; border-radius: 10px; box-sizing: border-box; }
    .row textarea { min-height: 96px; font-size: 15px; line-height: 1.4; }

    .drag-placeholder { height: 58px; border: 2px dashed #cfcfcf; border-radius: 12px; margin: 8px 0; }

    /* Notes Manager (unchanged) */
    .note-row {
      display: grid;
      grid-template-columns: 28px 1fr auto 24px;
      align-items: center;
      gap: 10px;
      padding: 10px 8px;
      border: 1px solid #eee;
      border-radius: 12px;
      background: #fff;
      margin-bottom: 8px;
      position: relative;
      touch-action: pan-y;
    }
    .note-row.dragging { opacity: 0.9; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .note-editor { display: none; grid-column: 1 / -1; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #eee; }
    .note-row.expanded .note-editor { display: block; }
    .note-editor .row { display: flex; gap: 8px; margin-bottom: 8px; }
    .note-editor input[type="text"] { flex: 1; padding: 10px 12px; font-size: 15px; border: 1px solid #ddd; border-radius: 10px; }
    .note-editor textarea { width: 100%; min-height: 140px; font-size: 15px; line-height: 1.4; border: 1px solid #ddd; border-radius: 10px; padding: 8px 10px; box-sizing: border-box; }
    .note-editor .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px; }

    /* Drawing overlay + saved images */
    #pad { position: absolute; inset: 8px; width: calc(100% - 16px); height: calc(100% - 16px); touch-action: none; border-radius: 6px; pointer-events: none; }
    .drawing-active #pad { pointer-events: auto; }
    #drawings img { max-width: 100%; height: auto; display: block; margin: 4px 0; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="bar">
        <div style="display:flex; gap:8px;">
          <!-- Chime button inserted BEFORE the font-size buttons -->
          <button class="btn btn-large" id="chime" type="button" aria-label="Play chime">🔔</button>
          <button class="btn btn-large" id="bigger" type="button">A+</button>
          <button class="btn btn-large" id="smaller" type="button">A−</button>
          <button class="btn btn-large" id="toggleDraw" type="button" aria-pressed="false">Draw: Off</button>
        </div>

        <div class="notes-controls">
          <select id="notesPicker" class="notes-picker"><option value="">Notes ▾</option></select>
          <button class="btn btn-large" id="manageNotes" type="button">Manage Notes</button>
          <button class="btn btn-clear" id="clear" type="button">CLEAR</button>
        </div>
      </div>

      <!-- quickbar: sections row + phrases row -->
      <div class="quickbar">
        <div class="rowbar" id="sectionsBar">
          <!-- section chips injected here -->
          <button class="edit-phrases" id="editPhrases" type="button">Edit Phrases</button>
        </div>

        <!-- wrapper to animate slide -->
        <div id="phrasesWrap" class="">
          <div class="rowbar" id="phrasesBar">
            <!-- phrase chips for active section injected here -->
          </div>
        </div>
      </div>
    </div>

    <div class="area">
      <div id="drawings"></div>
      <canvas id="pad"></canvas>
      <textarea id="board" placeholder="Type here…"></textarea>
    </div>
  </div>

  <!-- Manage PHRASES (sections) dialog -->
  <dialog id="phrasesDlg">
    <div class="dlg-head">Quick Phrases — Sections</div>
    <div class="dlg-body">
      <div class="note">Create sections (e.g., <b>Hospital</b>, <b>Home</b>, <b>Core</b>), then add phrases separated by commas or new lines. Drag ☰ to reorder sections.</div>
      <div id="sectionsList"></div>
      <button class="btn btn-sec" id="addSection" type="button">+ Add section</button>
    </div>
    <div class="dlg-foot">
      <button class="btn btn-sec" id="phrasesCancel" type="button">Close</button>
      <button class="btn btn-clear" id="phrasesSave" type="button">Save Changes</button>
    </div>
  </dialog>

  <!-- Notes Manager dialog -->
  <dialog id="notesDlg">
    <div class="dlg-head">Notes</div>
    <div class="dlg-body">
      <div class="note">Tap a note to edit. Drag the <b>☰</b> handle to reorder. Titles max 40 chars.</div>
      <div id="notesList"></div>
      <button class="btn btn-sec" id="addNote" type="button">+ Add note</button>
    </div>
    <div class="dlg-foot">
      <button class="btn btn-sec" id="notesCancel" type="button">Close</button>
      <button class="btn btn-clear" id="notesSave" type="button">Save Changes</button>
    </div>
  </dialog>

  <script>
    /* ===============================
       ELEMENTS (no duplicates)
    =============================== */
    const board          = document.getElementById('board');
    const clearBtn       = document.getElementById('clear');
    const bigger         = document.getElementById('bigger');
    const smaller        = document.getElementById('smaller');
    const sectionsBar    = document.getElementById('sectionsBar');
    const phrasesWrap    = document.getElementById('phrasesWrap');
    const phrasesBar     = document.getElementById('phrasesBar');
    const editBtn        = document.getElementById('editPhrases');

    // Phrases dialog
    const phrasesDlg     = document.getElementById('phrasesDlg');
    const sectionsList   = document.getElementById('sectionsList');
    const addSectionBtn  = document.getElementById('addSection');
    const phrasesCancel  = document.getElementById('phrasesCancel');
    const phrasesSave    = document.getElementById('phrasesSave');

    // Notes dialog
    const NOTES_KEY       = 'typeboard.notes';
    const NOTES_TITLE_MAX = 40;
    const notesDlg        = document.getElementById('notesDlg');
    const notesList       = document.getElementById('notesList');
    const addNoteBtn      = document.getElementById('addNote');
    const notesCancel     = document.getElementById('notesCancel');
    const notesSaveBtn    = document.getElementById('notesSave');
    const notesPicker     = document.getElementById('notesPicker');
    const manageNotesBtn  = document.getElementById('manageNotes');

    /* ===============================
       QUICK PHRASES — WITH SECTIONS
    =============================== */
    const PHRASES_V2_KEY = 'typeboard.phrases.v2';
    const PHRASES_V1_KEY = 'typeboard.phrases'; // old simple list

    const DEFAULT_SECTIONS = [
      { title: 'Core',     phrases: ['Sí','No','Gracias','Por favor','Perfecto','No lo sé'] },
      { title: 'Hospital', phrases: ['Gasas','Médico','Dolor','Comida','Enfermera','Lavabo'] },
      { title: 'Tiempo',   phrases: ['Hoy','Mañana','Ahora','Luego'] }
    ];

    function loadSections() {
      try {
        const raw = localStorage.getItem(PHRASES_V2_KEY);
        if (raw) {
          const obj = JSON.parse(raw);
          if (Array.isArray(obj?.sections)) return sanitizeSections(obj.sections);
        }
      } catch {}
      try {
        const raw1 = localStorage.getItem(PHRASES_V1_KEY);
        if (raw1) {
          const list = JSON.parse(raw1);
          if (Array.isArray(list) && list.length) {
            const migrated = [{ title: 'Phrases', phrases: list.filter(Boolean) }];
            saveSections(migrated);
            return sanitizeSections(migrated);
          }
        }
      } catch {}
      return DEFAULT_SECTIONS.slice();
    }
    function sanitizeSections(arr) {
      return arr.map(s => ({
        title: (s.title || '').toString().trim() || 'Untitled',
        phrases: Array.isArray(s.phrases) ? s.phrases.map(p => p.toString()).filter(Boolean) : []
      })).filter(sec => sec.phrases.length || sec.title);
    }
    function saveSections(secs) {
      localStorage.setItem(PHRASES_V2_KEY, JSON.stringify({ sections: secs }));
    }

    let SECTIONS = loadSections();
    // Only one section open at a time; null = collapsed (no phrases visible)
    let activeSection = null;

    function renderSectionsBar() {
      // remove old section chips (keep Edit button at the end)
      sectionsBar.querySelectorAll('.chip.section').forEach(el => el.remove());

      SECTIONS.forEach((sec, idx) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        const isActive = activeSection === idx;
        chip.className = 'chip section' + (isActive ? ' active' : '');
        chip.textContent = sec.title || 'Untitled';
        chip.addEventListener('click', () => toggleSection(idx));

        // Long-press quick rename/delete
        let timer;
        chip.addEventListener('touchstart', () => {
          timer = setTimeout(() => {
            const action = prompt('Edit section title or type DELETE to remove:', sec.title);
            if (action === null) return;
            if (action.trim().toUpperCase() === 'DELETE') {
              if (confirm(`Delete section "${sec.title}"?`)) {
                SECTIONS.splice(idx, 1);
                if (activeSection === idx) activeSection = null;
                else if (typeof activeSection === 'number' && idx < activeSection) activeSection -= 1;
                saveSections(SECTIONS);
                renderSectionsBar(); renderPhrasesBar();
              }
            } else {
              const newTitle = action.trim();
              if (newTitle) {
                sec.title = newTitle;
                saveSections(SECTIONS);
                renderSectionsBar();
              }
            }
          }, 600);
        }, {passive:true});
        chip.addEventListener('touchend', () => clearTimeout(timer), {passive:true});
        chip.addEventListener('touchmove', () => clearTimeout(timer), {passive:true});

        sectionsBar.insertBefore(chip, editBtn);
      });
    }

    function renderPhrasesBar() {
      phrasesBar.innerHTML = '';
      if (activeSection === null || !SECTIONS.length) {
        collapsePhrases(true);
        return;
      }
      const sec = SECTIONS[activeSection] || { phrases: [] };
      sec.phrases.forEach((txt, idx) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = txt;

        chip.addEventListener('click', () => {
          const needsSpace = board.value && !board.value.endsWith(' ');
          board.value = (board.value || '') + (needsSpace ? ' ' : '') + txt;
          board.focus();
          board.selectionStart = board.selectionEnd = board.value.length;
        });

        chip.addEventListener('dblclick', (e) => {
          e.preventDefault();
          board.value = txt;
          board.focus();
        });

        // Long-press edit/delete
        let pressTimer;
        chip.addEventListener('touchstart', () => {
          pressTimer = setTimeout(() => {
            const action = prompt('Edit phrase text or type DELETE to remove:', txt);
            if (action === null) return;
            if (action.trim().toUpperCase() === 'DELETE') {
              sec.phrases.splice(idx, 1);
              saveSections(SECTIONS);
              renderPhrasesBar();
            } else {
              const newTxt = action.trim();
              if (newTxt) {
                sec.phrases[idx] = newTxt;
                saveSections(SECTIONS);
                renderPhrasesBar();
              }
            }
          }, 550);
        }, {passive:true});
        chip.addEventListener('touchend', () => clearTimeout(pressTimer), {passive:true});
        chip.addEventListener('touchmove', () => clearTimeout(pressTimer), {passive:true});

        phrasesBar.appendChild(chip);
      });

      // expand with animation
      collapsePhrases(false);
    }

    function toggleSection(idx) {
      // If tapping same -> collapse; else open that one
      if (activeSection === idx) {
        activeSection = null;
        renderSectionsBar();
        renderPhrasesBar();
      } else {
        activeSection = idx;
        renderSectionsBar();
        renderPhrasesBar();
      }
    }

    // Slide animation helpers
    function collapsePhrases(shouldCollapse) {
      if (shouldCollapse) {
        phrasesWrap.style.maxHeight = phrasesWrap.scrollHeight + 'px'; // set current
        // force reflow then collapse
        void phrasesWrap.offsetHeight;
        phrasesWrap.classList.add('collapsed');
        phrasesWrap.style.maxHeight = '0px';
      } else {
        phrasesWrap.classList.remove('collapsed');
        // set to content height then clear after transition
        phrasesWrap.style.maxHeight = phrasesBar.scrollHeight + 'px';
        // after transition ends, set to 'none' so future content changes aren't clipped
        phrasesWrap.addEventListener('transitionend', function tidy(e){
          if (e.propertyName === 'max-height') {
            phrasesWrap.style.maxHeight = 'none';
            phrasesWrap.removeEventListener('transitionend', tidy);
          }
        });
      }
    }

    // Manage dialog (sections editor)
    function openPhrasesManager() {
      sectionsList.innerHTML = '';
      SECTIONS.forEach(sec => addSectionRow(sec.title, sec.phrases.join('\n'), false));
      phrasesDlg.showModal();
    }

    function addSectionRow(title = '', phrasesText = '', autoExpand = true) {
      const row = document.createElement('div'); row.className = 'sec-row';

      const handle = document.createElement('div'); handle.className = 'handle'; handle.textContent = '☰'; handle.title = 'Drag to reorder';
      const titleSpan = document.createElement('div'); titleSpan.className = 'title'; titleSpan.textContent = title || 'Untitled';
      const delInline = document.createElement('button'); delInline.type = 'button'; delInline.className = 'delete-inline'; delInline.textContent = 'Delete';
      const chev = document.createElement('div'); chev.className = 'chev'; chev.textContent = '›';

      const editor = document.createElement('div'); editor.className = 'sec-editor';
      editor.innerHTML = `
        <div class="row">
          <input type="text" class="title-input" placeholder="Section title" value="">
        </div>
        <div class="row">
          <textarea class="phrases-input" placeholder="Phrases (comma or new line separated)"></textarea>
        </div>
        <div class="row" style="justify-content:flex-end; color:#666; font-size:13px;">
          Changes apply when you press “Save Changes”.
        </div>
      `;

      row.append(handle, titleSpan, delInline, chev, editor);
      sectionsList.appendChild(row);

      const titleInput = editor.querySelector('.title-input');
      const phrasesInput = editor.querySelector('.phrases-input');
      titleInput.value = title;
      phrasesInput.value = phrasesText;

      function toggleExpand() {
        const exp = row.classList.toggle('expanded');
        chev.textContent = exp ? '▾' : '›';
        if (exp) { titleInput.focus(); titleInput.select(); }
      }
      titleSpan.addEventListener('click', toggleExpand);
      chev.addEventListener('click', toggleExpand);

      titleInput.addEventListener('input', (e) => {
        const t = e.target.value.trim();
        titleSpan.textContent = t || 'Untitled';
      });

      delInline.addEventListener('click', () => {
        if (confirm('Delete this section?')) row.remove();
      });

      enableSectionDrag(row, handle);

      if (autoExpand) {
        row.classList.add('expanded');
        chev.textContent = '▾';
        setTimeout(() => { titleInput.focus(); titleInput.select(); }, 0);
      }
    }

    function enableSectionDrag(row, handle) {
      let dragging=false, startY=0, currentY=0, placeholder=null;

      const onDown = (e) => {
        e.preventDefault();
        dragging = true; startY = getY(e);
        row.classList.add('dragging');
        placeholder = document.createElement('div');
        placeholder.className = 'drag-placeholder';
        placeholder.style.height = row.getBoundingClientRect().height + 'px';
        sectionsList.insertBefore(placeholder, row.nextSibling);
        row.style.position='relative'; row.style.zIndex='1'; row.style.transform='translateY(0px)';

        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', onUp, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', onUp, {passive:false});
        window.addEventListener('mousemove', onMove, {passive:false});
        window.addEventListener('mouseup', onUp, {passive:false});
      };

      const onMove = (e) => {
        if(!dragging) return; e.preventDefault();
        currentY = getY(e);
        const dy = currentY - startY;
        row.style.transform = `translateY(${dy}px)`;
        const rowsArr = [...sectionsList.querySelectorAll('.sec-row')].filter(el => el !== row);
        let placed = false;
        for (const r of rowsArr) {
          const rect = r.getBoundingClientRect();
          if (currentY < rect.top + rect.height/2) { sectionsList.insertBefore(placeholder, r); placed = true; break; }
        }
        if (!placed) sectionsList.appendChild(placeholder);
      };

      const onUp = () => {
        if(!dragging) return; dragging=false;
        row.classList.remove('dragging'); row.style.position=''; row.style.zIndex=''; row.style.transform='';
        if (placeholder) { sectionsList.insertBefore(row, placeholder); placeholder.remove(); placeholder = null; }
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      };

      const getY = (e) => e.touches?.[0]?.clientY ?? e.changedTouches?.[0]?.clientY ?? e.clientY ?? 0;

      handle.addEventListener('pointerdown', onDown);
      handle.addEventListener('touchstart', onDown, {passive:false});
      handle.addEventListener('mousedown', onDown);
    }

    function collectSectionsFromDialog() {
      const rows = [...sectionsList.querySelectorAll('.sec-row')];
      const out = rows.map(r => {
        const t = r.querySelector('.title-input')?.value.trim() || r.querySelector('.title')?.textContent || 'Untitled';
        const raw = r.querySelector('.phrases-input')?.value || '';
        const phrases = raw.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
        return { title: t, phrases };
      });
      return sanitizeSections(out);
    }

    editBtn.addEventListener('click', openPhrasesManager);
    addSectionBtn.addEventListener('click', () => addSectionRow('', '', true));
    phrasesCancel.addEventListener('click', () => phrasesDlg.close());
    phrasesSave.addEventListener('click', () => {
      SECTIONS = collectSectionsFromDialog();
      saveSections(SECTIONS);
      // keep state: if activeSection is out of range, collapse
      if (typeof activeSection === 'number' && activeSection >= SECTIONS.length) activeSection = null;
      renderSectionsBar(); renderPhrasesBar();
      phrasesDlg.close();
    });

    /* ===============================
       NOTES
    =============================== */
    function loadNotes(){ try{ const raw=localStorage.getItem(NOTES_KEY); const arr=raw?JSON.parse(raw):[]; return Array.isArray(arr)?arr:[]; }catch{ return []; } }
    function saveNotes(arr){ localStorage.setItem(NOTES_KEY, JSON.stringify(arr)); }
    function renderNotesPicker(){ const arr=loadNotes(); notesPicker.innerHTML='<option value="">Notes ▾</option>'; arr.forEach((n,i)=>{ const opt=document.createElement('option'); opt.value=String(i); opt.textContent=n.title||`Note ${i+1}`; notesPicker.appendChild(opt); }); }

    notesPicker.addEventListener('change', ()=>{
      const idx=parseInt(notesPicker.value,10); const arr=loadNotes();
      if(!isNaN(idx) && arr[idx]){ const prefix=(board.value && !board.value.endsWith('\n'))?'\n':''; board.setRangeText(prefix+arr[idx].body, board.selectionStart??board.value.length, board.selectionEnd??board.value.length, 'end'); board.focus(); }
      notesPicker.value='';
    });

    manageNotesBtn.addEventListener('click', openNotesManager);

    function openNotesManager(){
      notesList.innerHTML='';
      const arr=loadNotes();
      if(arr.length>0){ arr.forEach(n=>addNoteRow(n.title,n.body,false)); }
      notesDlg.showModal();
    }

    function addNoteRow(title='', body='', autoExpand=false){
      const row=document.createElement('div'); row.className='note-row'; row.setAttribute('data-title',title);
      const handle=document.createElement('div'); handle.className='handle'; handle.textContent='☰'; handle.title='Drag to reorder';
      const titleSpan=document.createElement('div'); titleSpan.className='title'; titleSpan.textContent=title||'Untitled';
      const delInline=document.createElement('button'); delInline.type='button'; delInline.className='delete-inline'; delInline.textContent='Delete';
      const chev=document.createElement('div'); chev.className='chev'; chev.textContent='›';
      const editor=document.createElement('div'); editor.className='note-editor';
      editor.innerHTML = `
        <div class="row">
          <input type="text" class="title-input" placeholder="Note title (max ${NOTES_TITLE_MAX} chars)" maxlength="${NOTES_TITLE_MAX}">
        </div>
        <textarea class="body-input" placeholder="Write your note text here..."></textarea>
        <div class="actions"><span style="font-size:13px;color:#666;">Changes are saved with “Save Changes”.</span></div>
      `;
      row.append(handle, titleSpan, delInline, chev, editor);
      notesList.appendChild(row);
      const titleInput=editor.querySelector('.title-input');
      const bodyInput=editor.querySelector('.body-input');
      titleInput.value = title.slice(0,NOTES_TITLE_MAX);
      bodyInput.value = body;

      function toggleExpand(){ const exp=row.classList.toggle('expanded'); chev.textContent = exp ? '▾' : '›'; if(exp){ titleInput.focus(); titleInput.select(); } }
      titleSpan.addEventListener('click', toggleExpand);
      chev.addEventListener('click', toggleExpand);

      titleInput.addEventListener('input', (e)=>{ const t=e.target.value.trim(); titleSpan.textContent=t||'Untitled'; });
      const doDelete = () => { if (confirm('Delete this note?')) row.remove(); };
      delInline.addEventListener('click', doDelete);

      enableRowDrag(row, handle);

      if(autoExpand){
        row.classList.add('expanded'); chev.textContent='▾';
        setTimeout(()=>{ titleInput.focus(); titleInput.select(); }, 0);
      }

      editor.style.gridColumn = '1 / -1';
    }

    function enableRowDrag(row, handle){
      let dragging=false, startY=0, currentY=0, placeholder=null;
      const onDown=(e)=>{
        e.preventDefault();
        dragging=true; startY=getY(e);
        row.classList.add('dragging');
        placeholder=document.createElement('div'); placeholder.className='drag-placeholder'; placeholder.style.height = row.getBoundingClientRect().height+'px';
        notesList.insertBefore(placeholder, row.nextSibling);
        row.style.position='relative'; row.style.zIndex='1'; row.style.transform='translateY(0px)';

        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', onUp, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', onUp, {passive:false});
        window.addEventListener('mousemove', onMove, {passive:false});
        window.addEventListener('mouseup', onUp, {passive:false});
      };
      const onMove=(e)=>{
        if(!dragging) return; e.preventDefault();
        currentY=getY(e); const dy=currentY-startY; row.style.transform=`translateY(${dy}px)`;
        const rowsArr=[...notesList.querySelectorAll('.note-row')].filter(el=>el!==row);
        let placed=false;
        for(const r of rowsArr){
          const rect=r.getBoundingClientRect();
          if(currentY < rect.top + rect.height/2){ notesList.insertBefore(placeholder, r); placed=true; break; }
        }
        if(!placed) notesList.appendChild(placeholder);
      };
      const onUp=()=>{
        if(!dragging) return; dragging=false;
        row.classList.remove('dragging'); row.style.position=''; row.style.zIndex=''; row.style.transform='';
        if(placeholder){ notesList.insertBefore(row, placeholder); placeholder.remove(); placeholder=null; }

        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      };
      const getY=(e)=> e.touches?.[0]?.clientY ?? e.changedTouches?.[0]?.clientY ?? e.clientY ?? 0;

      handle.addEventListener('pointerdown', onDown);
      handle.addEventListener('touchstart', onDown, {passive:false});
      handle.addEventListener('mousedown', onDown);
    }

    function getY(e){ return e.touches?.[0]?.clientY ?? e.changedTouches?.[0]?.clientY ?? e.clientY ?? 0; }

    /* ===============================
       CLEAR / FONT SIZE / LOAD
    =============================== */
 window.addEventListener('load', ()=>{ 
  renderSectionsBar();
  renderPhrasesBar();
  renderNotesPicker();
  board.focus();
  board.selectionStart = board.selectionEnd = board.value.length; // put caret at end
  sizeCanvas();
});


    clearBtn.addEventListener('click', ()=>{ board.value=''; drawings.innerHTML=''; const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); dirty=false; board.focus(); });

    function getSize(){ const s=window.getComputedStyle(board).fontSize; return parseFloat(s||'28'); }
    bigger.addEventListener('click', ()=>{ board.style.fontSize = Math.min(getSize()+4, 72)+'px'; board.focus(); });
    smaller.addEventListener('click', ()=>{ board.style.fontSize = Math.max(getSize()-4, 14)+'px'; board.focus(); });

    document.addEventListener('keydown',(e)=>{ if((e.metaKey||e.ctrlKey) && (e.key==='Backspace'||e.key==='Delete')){ e.preventDefault(); board.value=''; drawings.innerHTML=''; const rect=pad.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); dirty=false; } });

    /* ===============================
       OPEN NOTES / SAVE NOTES
    =============================== */
    manageNotesBtn.addEventListener('click', openNotesManager);
    addNoteBtn.addEventListener('click', ()=> addNoteRow('', '', true));
    notesCancel.addEventListener('click', ()=> notesDlg.close());
    notesSaveBtn.addEventListener('click', ()=>{
      const rowsDom=[...notesList.querySelectorAll('.note-row')];
      const arr=rowsDom.map(r=>{
        const t=(r.querySelector('.title-input')?.value.trim() || r.getAttribute('data-title') || '').slice(0,NOTES_TITLE_MAX);
        const b=r.querySelector('.body-input')?.value || '';
        return { title: t || 'Untitled', body: b };
      });
      saveNotes(arr); renderNotesPicker(); notesDlg.close();
    });

    /* ===============================
       DRAWING
    =============================== */
    const drawings   = document.getElementById('drawings');
    const pad        = document.getElementById('pad');
    const ctx        = pad.getContext('2d');
    const toggleDraw = document.getElementById('toggleDraw');
    let drawing=false, drawActive=false, dirty=false;
    let lastX=0, lastY=0, dpr=1;

    function sizeCanvas(){
      const rect=pad.getBoundingClientRect();
      dpr=window.devicePixelRatio||1;
      ctx.setTransform(1,0,0,1,0,0);
      pad.width=Math.max(1, Math.floor(rect.width*dpr));
      pad.height=Math.max(1, Math.floor(rect.height*dpr));
      ctx.scale(dpr,dpr);
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty=false;
    }
    function startDraw(x,y){ drawing=true; lastX=x; lastY=y; }
    function moveDraw(x,y){ if(!drawing) return; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#111'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y; dirty=true; }
    function endDraw(){ drawing=false; }
    function getPoint(e){ const rect=pad.getBoundingClientRect(); if(e.touches&&e.touches.length){ const t=e.touches[0]; return {x:t.clientX-rect.left, y:t.clientY-rect.top}; } return {x:e.clientX-rect.left, y:e.clientY-rect.top}; }

    function getVerticalContentBounds(){
      const w=pad.width, h=pad.height;
      if(!dirty||!w||!h) return null;
      try{
        const data=ctx.getImageData(0,0,w,h).data;
        let topFound=false, bottomFound=false, top=0, bottom=h-1;
        for(let y=0;y<h;y++){
          const row=y*w*4;
          for(let x=0;x<w;x++){
            if(data[row+x*4+3]!==0){ top=y; topFound=true; break; }
          }
          if(topFound) break;
        }
        if(!topFound) return null;
        for(let y=h-1;y>=0;y--){
          const row=y*w*4;
          for(let x=0;x<w;x++){
            if(data[row+x*4+3]!==0){ bottom=y; bottomFound=true; break; }
          }
          if(bottomFound) break;
        }
        return {top,bottom};
      }catch{ return null; }
    }
    function saveDrawingIfAny(){
      if(!dirty) return;
      const w=pad.width,h=pad.height;
      const b=getVerticalContentBounds();
      let sy=0,sh=h;
      const cssDpr=window.devicePixelRatio||1;
      const margin=Math.round(cssDpr*2);
      if(b){
        sy=Math.max(0,b.top-margin);
        const bt=Math.min(h-1,b.bottom+margin);
        sh=Math.max(1, bt-sy+1);
      }
      const off=document.createElement('canvas');
      off.width=w; off.height=sh;
      const offCtx=off.getContext('2d');
      offCtx.drawImage(pad,0,sy,w,sh,0,0,w,sh);
      const img=new Image();
      img.src=off.toDataURL('image/png');
      drawings.appendChild(img);
      const rect=pad.getBoundingClientRect();
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty=false;
      board.focus();
    }

    toggleDraw.addEventListener('click', ()=>{
      saveDrawingIfAny();
      drawActive=!drawActive;
      toggleDraw.textContent = drawActive ? 'Draw: On' : 'Draw: Off';
      toggleDraw.setAttribute('aria-pressed', String(drawActive));
      document.body.classList.toggle('drawing-active', drawActive);
      if(drawActive){ board.blur(); sizeCanvas(); } else { board.focus(); }
    });

   pad.addEventListener('touchstart', (e) => {
  if (!drawActive) return;
  e.preventDefault();
  const p = getPoint(e);
  startDraw(p.x, p.y);
}, { passive: false });

pad.addEventListener('touchmove', (e) => {
  if (!drawActive) return;
  e.preventDefault();
  const p = getPoint(e);
  moveDraw(p.x, p.y);
}, { passive: false });

pad.addEventListener('touchend', (e) => {
  if (!drawActive) return;
  e.preventDefault();
  endDraw();
}, { passive: false });

// (Optional but recommended) handle interrupted touches
pad.addEventListener('touchcancel', (e) => {
  if (!drawActive) return;
  e.preventDefault();
  endDraw();
}, { passive: false });

    pad.addEventListener('mousedown',(e)=>{ if(!drawActive) return; const p=getPoint(e); startDraw(p.x,p.y); });
    pad.addEventListener('mousemove',(e)=>{ if(!drawActive) return; const p=getPoint(e); moveDraw(p.x,p.y); });
    pad.addEventListener('mouseup', endDraw);
    pad.addEventListener('mouseleave', endDraw);
    window.addEventListener('resize', sizeCanvas);

    // Prevent page scroll while drawing on iOS
document.addEventListener('touchmove', (e) => {
  if (drawActive) e.preventDefault();
}, { passive: false });


    /* ===============================
       CHIME — gentle double bell
       (added without changing any existing code)
    =============================== */
    const chime = document.getElementById('chime');
    let chimeCtx; // created on first use

    function playGentleChimeTwice() {
      if (!chimeCtx) chimeCtx = new (window.AudioContext || window.webkitAudioContext)();
      const now = chimeCtx.currentTime;

      // Soft overall volume
      const master = chimeCtx.createGain();
      master.gain.value = 0.15;
      master.connect(chimeCtx.destination);

      // first chime now, second after a short pause
      bell(now, master);
      bell(now + 0.45, master);
    }

    function bell(startTime, outputNode) {
      // three soft oscillators for a pleasant bell-like chime
      const o1 = chimeCtx.createOscillator();
      const o2 = chimeCtx.createOscillator();
      const o3 = chimeCtx.createOscillator();

      o1.type = 'sine';     o1.frequency.setValueAtTime(880, startTime);     // A5
      o2.type = 'sine';     o2.frequency.setValueAtTime(1760, startTime);    // gentle harmonic
      o2.detune.setValueAtTime(6, startTime);                                // tiny shimmer
      o3.type = 'triangle'; o3.frequency.setValueAtTime(440, startTime);     // body

      const g = chimeCtx.createGain();
      // gentle envelope (fast attack, smooth decay)
      g.gain.setValueAtTime(0.0001, startTime);
      g.gain.exponentialRampToValueAtTime(0.9, startTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.9);

      // tame highs a touch to avoid harshness
      const filter = chimeCtx.createBiquadFilter();
      filter.type = 'highshelf';
      filter.frequency.setValueAtTime(3000, startTime);
      filter.gain.setValueAtTime(-2, startTime);

      o1.connect(g); o2.connect(g); o3.connect(g);
      g.connect(filter); filter.connect(outputNode);

      o1.start(startTime); o2.start(startTime); o3.start(startTime);
      const stopTime = startTime + 1.2;
      o1.stop(stopTime); o2.stop(stopTime); o3.stop(stopTime);
    }

    if (chime) {
      chime.addEventListener('click', () => {
        // Needed on iOS/Safari sometimes
        if (chimeCtx && chimeCtx.state === 'suspended') chimeCtx.resume();
        playGentleChimeTwice();
      });
    }
  </script>
</body>
</html>
