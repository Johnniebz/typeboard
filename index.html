<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>Typeboard — Quick Phrases</title>
  <style>
    :root { --pad: 10px; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: #ffffff;
      color: #111;
    }
.wrap {
  height: 100svh;       /* force full screen height */
  display: flex;
  flex-direction: column;
}

.area {
  flex: 1;              /* fill all remaining height under header */
  overflow-y: auto;     /* scroll inside here */
  padding: 8px;
  position: relative;
  -webkit-overflow-scrolling: touch;
}

    /* Sticky header (bar + quickbar) */
    .header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #fff;
      border-bottom: 1px solid #eee;
    }

    .bar {
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .btn {
      padding: 10px 14px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    .btn-clear {
      background: #ff3b30;
      color: #fff;
      font-weight: 700;
    }
    .btn-large {
      background: #f2f2f7;
      color: #111;
    }

    /* Notes controls */
    .notes-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .notes-picker {
      appearance: none;
      -webkit-appearance: none;
      padding: 10px 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fff;
    }

    .quickbar {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 8px;
      border-top: 1px solid #f6f6f6;
      border-bottom: 1px solid #f1f1f1;
      background: #fff;
    }
    .chip {
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 20px;
      border: 1px solid #ddd;
      background: #fafafa;
      font-weight: 600;
      font-size: 16px;
      user-select: none;
    }
    .chip:active { background: #f0f0f0; }
    .edit-phrases {
      margin-left: auto;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fff;
      font-weight: 600;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: none;
      outline: none;
      resize: none;
      font-size: 28px;
      line-height: 1.4;
      -webkit-appearance: none;
    }

    /* Dialog */
    dialog::backdrop { background: rgba(0,0,0,0.35); }
    dialog {
      border: none;
      border-radius: 16px;
      max-width: 600px;
      width: calc(100% - 32px);
      padding: 0;
      overflow: hidden;
    }
    .dlg-head {
      padding: 14px 16px;
      font-weight: 700;
      border-bottom: 1px solid #eee;
      background: #fafafa;
    }
    .dlg-body { padding: 12px 16px; max-height: 60vh; overflow: auto; }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .row input[type="text"] {
      flex: 1;
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 10px;
    }
    .dlg-foot {
      display: flex;
      gap: 10px;
      padding: 12px 16px;
      border-top: 1px solid #eee;
      justify-content: flex-end;
      background: #fafafa;
    }
    .btn-sec {
      background: #f2f2f7;
      color: #111;
    }
    .note {
      font-size: 13px;
      color: #666;
      margin-bottom: 10px;
    }

    /* Notes Manager styles */
    .note-card {
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
      background: #fff;
    }
    .note-card .title-line {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .note-card .title-line input[type="text"] {
      flex: 1;
    }
    .note-card textarea {
      width: 100%;
      min-height: 100px;
      font-size: 15px;
      line-height: 1.4;
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 8px 10px;
    }
    .note-card .actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      justify-content: flex-end;
    }

    /* Drawing overlay + saved images */
    #pad {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 8px;
      /* top is set dynamically to sit under the caret if you add caret positioning */
      width: auto;
      height: auto;
      touch-action: none;
      border-radius: 6px;
      pointer-events: none;
    }
    .drawing-active #pad { pointer-events: auto; }
    #drawings img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 4px 0;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="bar">
        <div style="display:flex; gap:8px;">
          <button class="btn btn-large" id="bigger" type="button">A+</button>
          <button class="btn btn-large" id="smaller" type="button">A−</button>
          <button class="btn btn-large" id="toggleDraw" type="button" aria-pressed="false">Draw: Off</button>
        </div>

        <div class="notes-controls">
          <select id="notesPicker" class="notes-picker">
            <option value="">Notes ▾</option>
          </select>
          <button class="btn btn-large" id="manageNotes" type="button">Manage Notes</button>
          <button class="btn btn-clear" id="clear" type="button">CLEAR</button>
        </div>
      </div>

      <div class="quickbar" id="quickbar">
        <!-- chips injected here -->
        <button class="edit-phrases" id="editPhrases" type="button">Edit Phrases</button>
      </div>
    </div>

    <div class="area">
      <div id="drawings"></div>
      <canvas id="pad"></canvas>
      <textarea id="board" placeholder="Type here…"></textarea>
    </div>
  </div>

  <!-- Phrases dialog (existing) -->
  <dialog id="dlg">
    <div class="dlg-head">Quick Phrases</div>
    <div class="dlg-body">
      <div class="note">Tap to edit your most-used phrases. They’ll be saved on this device.</div>
      <div id="rows"></div>
      <button class="btn btn-sec" id="addRow" type="button">+ Add phrase</button>
    </div>
    <div class="dlg-foot">
      <button class="btn btn-sec" id="reset" type="button">Reset</button>
      <button class="btn btn-sec" id="cancel" type="button">Cancel</button>
      <button class="btn btn-clear" id="save" type="button">Save</button>
    </div>
  </dialog>

  <!-- Notes Manager dialog (NEW) -->
  <dialog id="notesDlg">
    <div class="dlg-head">Notes</div>
    <div class="dlg-body">
      <div class="note">Create longer messages you can insert quickly. Titles are limited to 40 characters.</div>
      <div id="notesList"></div>
      <button class="btn btn-sec" id="addNote" type="button">+ Add note</button>
    </div>
    <div class="dlg-foot">
      <button class="btn btn-sec" id="notesCancel" type="button">Close</button>
      <button class="btn btn-clear" id="notesSave" type="button">Save Changes</button>
    </div>
  </dialog>

  <script>
    const board = document.getElementById('board');
    const clearBtn = document.getElementById('clear');
    const bigger = document.getElementById('bigger');
    const smaller = document.getElementById('smaller');
    const quickbar = document.getElementById('quickbar');
    const editBtn = document.getElementById('editPhrases');
    const dlg = document.getElementById('dlg');
    const rows = document.getElementById('rows');
    const addRow = document.getElementById('addRow');
    const cancel = document.getElementById('cancel');
    const save = document.getElementById('save');
    const reset = document.getElementById('reset');

    /* -------- Phrases (existing) -------- */
    const DEFAULTS = [
      "Sí","No","No lo sé", "Perfecto", "Necesito", "Lavabo", "Gasas", "Me pasas", "Hoy", "Mañana"
    ];

    function loadPhrases() {
      try {
        const raw = localStorage.getItem('typeboard.phrases');
        const arr = raw ? JSON.parse(raw) : DEFAULTS.slice();
        if (!Array.isArray(arr) || arr.length === 0) return DEFAULTS.slice();
        return arr.slice(0, 20);
      } catch(e) {
        return DEFAULTS.slice();
      }
    }
    function savePhrases(list) {
      localStorage.setItem('typeboard.phrases', JSON.stringify(list.filter(Boolean)));
    }

    function renderChips() {
      const list = loadPhrases();
      quickbar.querySelectorAll('.chip').forEach(c => c.remove());
      const edit = editBtn;
      list.forEach((txt, idx) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = txt;
        chip.addEventListener('click', () => {
          const needsSpace = board.value && !board.value.endsWith(' ');
          board.value = (board.value || '') + (needsSpace ? ' ' : '') + txt;
          board.focus();
          board.selectionStart = board.selectionEnd = board.value.length;
        });
        chip.addEventListener('dblclick', (e) => {
          e.preventDefault();
          board.value = txt;
          board.focus();
        });
        let pressTimer;
        chip.addEventListener('touchstart', () => {
          pressTimer = setTimeout(() => {
            const newTxt = prompt('Edit phrase:', txt);
            if (newTxt !== null) {
              const list2 = loadPhrases();
              list2[idx] = newTxt.trim();
              savePhrases(list2);
              renderChips();
            }
          }, 550);
        });
        chip.addEventListener('touchend', () => clearTimeout(pressTimer));
        chip.addEventListener('touchmove', () => clearTimeout(pressTimer));
        quickbar.insertBefore(chip, edit);
      });
    }

    function openEditor() {
      rows.innerHTML = '';
      const list = loadPhrases();
      list.forEach((txt) => addEditorRow(txt));
      if (list.length === 0) addEditorRow('');
      dlg.showModal();
    }

    function addEditorRow(val='') {
      const row = document.createElement('div');
      row.className = 'row';
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Phrase';
      input.value = val;
      const del = document.createElement('button');
      del.type = 'button';
      del.textContent = 'Delete';
      del.className = 'btn btn-sec';
      del.addEventListener('click', () => row.remove());
      row.appendChild(input);
      row.appendChild(del);
      rows.appendChild(row);
    }

    window.addEventListener('load', () => {
      renderChips();
      renderNotesPicker();
      board.focus();
      sizeCanvas();
    });

    // CLEAR now wipes text, saved drawings, and any unsaved sketch
    clearBtn.addEventListener('click', () => {
      board.value = '';
      drawings.innerHTML = '';
      const rect = pad.getBoundingClientRect();
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty = false;
      board.focus();
    });

    function getSize() {
      const s = window.getComputedStyle(board).fontSize;
      return parseFloat(s || '28');
    }
    bigger.addEventListener('click', () => {
      board.style.fontSize = Math.min(getSize() + 4, 72) + 'px';
      board.focus();
    });
    smaller.addEventListener('click', () => {
      board.style.fontSize = Math.max(getSize() - 4, 14) + 'px';
      board.focus();
    });

    editBtn.addEventListener('click', openEditor);
    addRow.addEventListener('click', () => addEditorRow(''));
    cancel.addEventListener('click', () => dlg.close());
    reset.addEventListener('click', () => {
      if (confirm('Reset phrases to defaults?')) {
        savePhrases(DEFAULTS.slice());
        renderChips();
        dlg.close();
      }
    });
    save.addEventListener('click', () => {
      const inputs = Array.from(rows.querySelectorAll('input[type="text"]'));
      const list = inputs.map(i => i.value.trim()).filter(Boolean);
      savePhrases(list);
      renderChips();
      dlg.close();
    });

    // Keyboard shortcut: Cmd/Ctrl + Backspace to clear EVERYTHING
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && (e.key === 'Backspace' || e.key === 'Delete')) {
        e.preventDefault();
        board.value = '';
        drawings.innerHTML = '';
        const rect = pad.getBoundingClientRect();
        ctx.clearRect(0,0, rect.width, rect.height);
        dirty = false;
      }
    });

    /* -------- Notes (NEW) -------- */
    const NOTES_KEY = 'typeboard.notes';
    const NOTES_TITLE_MAX = 40;
    const notesDlg = document.getElementById('notesDlg');
    const notesList = document.getElementById('notesList');
    const addNoteBtn = document.getElementById('addNote');
    const notesCancel = document.getElementById('notesCancel');
    const notesSave = document.getElementById('notesSave');
    const notesPicker = document.getElementById('notesPicker');
    const manageNotesBtn = document.getElementById('manageNotes');

    function loadNotes() {
      try {
        const raw = localStorage.getItem(NOTES_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      } catch(e) { return []; }
    }
    function saveNotes(arr) {
      localStorage.setItem(NOTES_KEY, JSON.stringify(arr));
    }

    function renderNotesPicker() {
      const arr = loadNotes();
      // reset
      notesPicker.innerHTML = '<option value="">Notes ▾</option>';
      arr.forEach((n, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = n.title || `Note ${i+1}`;
        notesPicker.appendChild(opt);
      });
    }

    // Insert selected note at caret (append; preserves current text)
    notesPicker.addEventListener('change', () => {
      const idx = parseInt(notesPicker.value, 10);
      const arr = loadNotes();
      if (!isNaN(idx) && arr[idx]) {
        insertTextAtCursorTextarea(board, (board.value && !board.value.endsWith('\n') ? '\n' : '') + arr[idx].body);
        // move caret to end and refocus
        board.selectionStart = board.selectionEnd = board.value.length;
        board.focus();
      }
      // reset picker back to placeholder
      notesPicker.value = '';
    });

    manageNotesBtn.addEventListener('click', () => {
      openNotesManager();
    });

    function openNotesManager() {
      notesList.innerHTML = '';
      const arr = loadNotes();
      arr.forEach((n, i) => addNoteCard(n.title, n.body));
      if (arr.length === 0) addNoteCard('', '');
      notesDlg.showModal();
    }

    function addNoteCard(title = '', body = '') {
      const wrap = document.createElement('div');
      wrap.className = 'note-card';

      const titleLine = document.createElement('div');
      titleLine.className = 'title-line';
      const titleInput = document.createElement('input');
      titleInput.type = 'text';
      titleInput.placeholder = 'Note title (max 40 chars)';
      titleInput.value = title.slice(0, NOTES_TITLE_MAX);
      titleInput.maxLength = NOTES_TITLE_MAX;

      const upBtn = document.createElement('button');
      upBtn.type = 'button';
      upBtn.className = 'btn btn-sec';
      upBtn.textContent = 'Up';

      const downBtn = document.createElement('button');
      downBtn.type = 'button';
      downBtn.className = 'btn btn-sec';
      downBtn.textContent = 'Down';

      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.className = 'btn btn-sec';
      delBtn.textContent = 'Delete';

      titleLine.appendChild(titleInput);
      titleLine.appendChild(upBtn);
      titleLine.appendChild(downBtn);
      titleLine.appendChild(delBtn);

      const bodyInput = document.createElement('textarea');
      bodyInput.placeholder = 'Write your note text here...';
      bodyInput.value = body;

      const actions = document.createElement('div');
      actions.className = 'actions';
      const insertBtn = document.createElement('button');
      insertBtn.type = 'button';
      insertBtn.className = 'btn btn-large';
      insertBtn.textContent = 'Insert into typing area';
      actions.appendChild(insertBtn);

      wrap.appendChild(titleLine);
      wrap.appendChild(bodyInput);
      wrap.appendChild(actions);

      // Handlers
      delBtn.addEventListener('click', () => wrap.remove());

      upBtn.addEventListener('click', () => {
        const prev = wrap.previousElementSibling;
        if (prev) wrap.parentNode.insertBefore(wrap, prev);
      });
      downBtn.addEventListener('click', () => {
        const next = wrap.nextElementSibling;
        if (next) wrap.parentNode.insertBefore(next, wrap);
      });

      insertBtn.addEventListener('click', () => {
        // Insert body at caret in the main textarea, keep dialog open
        insertTextAtCursorTextarea(board, (board.value && !/[\s\n]$/.test(board.value) ? '\n' : '') + bodyInput.value);
        board.focus();
      });

      notesList.appendChild(wrap);
    }

    addNoteBtn.addEventListener('click', () => addNoteCard('', ''));

    notesCancel.addEventListener('click', () => notesDlg.close());

    notesSave.addEventListener('click', () => {
      // Collect all cards into an array in their current order
      const cards = Array.from(notesList.querySelectorAll('.note-card'));
      const arr = cards.map(card => {
        const t = card.querySelector('input[type="text"]').value.trim().slice(0, NOTES_TITLE_MAX);
        const b = card.querySelector('textarea').value;
        return { title: t || 'Untitled', body: b };
      });
      saveNotes(arr);
      renderNotesPicker();
      notesDlg.close();
    });

    // helper: insert text at cursor in a textarea
    function insertTextAtCursorTextarea(ta, text) {
      const start = ta.selectionStart ?? ta.value.length;
      const end = ta.selectionEnd ?? ta.value.length;
      const before = ta.value.slice(0, start);
      const after = ta.value.slice(end);
      ta.value = before + text + after;
      const pos = before.length + text.length;
      ta.selectionStart = ta.selectionEnd = pos;
    }

    /* -------- Drawing (existing) -------- */
    const drawings = document.getElementById('drawings');
    const pad = document.getElementById('pad');
    const ctx = pad.getContext('2d');
    const toggleDraw = document.getElementById('toggleDraw');
    let drawing = false, drawActive = false, dirty = false;
    let lastX = 0, lastY = 0, dpr = 1;

    function sizeCanvas() {
      const rect = pad.getBoundingClientRect();
      dpr = window.devicePixelRatio || 1;
      ctx.setTransform(1,0,0,1,0,0);
      pad.width = Math.max(1, Math.floor(rect.width * dpr));
      pad.height = Math.max(1, Math.floor(rect.height * dpr));
      ctx.scale(dpr, dpr);
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty = false;
    }
    function startDraw(x, y) { drawing = true; lastX = x; lastY = y; }
    function moveDraw(x, y) {
      if (!drawing) return;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y; dirty = true;
    }
    function endDraw() { drawing = false; }
    function getPoint(e) {
      const rect = pad.getBoundingClientRect();
      if (e.touches && e.touches.length) {
        const t = e.touches[0];
        return { x: t.clientX - rect.left, y: t.clientY - rect.top };
      }
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function getVerticalContentBounds() {
      const w = pad.width, h = pad.height;
      if (!dirty || w === 0 || h === 0) return null;
      try {
        const data = ctx.getImageData(0,0,w,h).data;
        let topFound = false, bottomFound = false, top = 0, bottom = h - 1;
        for (let y = 0; y < h; y++) {
          const row = y * w * 4;
          for (let x = 0; x < w; x++) {
            if (data[row + x*4 + 3] !== 0) { top = y; topFound = true; break; }
          }
          if (topFound) break;
        }
        if (!topFound) return null;
        for (let y = h - 1; y >= 0; y--) {
          const row = y * w * 4;
          for (let x = 0; x < w; x++) {
            if (data[row + x*4 + 3] !== 0) { bottom = y; bottomFound = true; break; }
          }
          if (bottomFound) break;
        }
        return { top, bottom };
      } catch { return null; }
    }
    function saveDrawingIfAny() {
      if (!dirty) return;
      const w = pad.width, h = pad.height;
      const bounds = getVerticalContentBounds();
      let sy = 0, sh = h;
      const cssDpr = window.devicePixelRatio || 1;
      const margin = Math.round(cssDpr * 2);
      if (bounds) {
        sy = Math.max(0, bounds.top - margin);
        const btm = Math.min(h - 1, bounds.bottom + margin);
        sh = Math.max(1, btm - sy + 1);
      }
      const off = document.createElement('canvas');
      off.width = w;
      off.height = sh;
      const offCtx = off.getContext('2d');
      offCtx.drawImage(pad, 0, sy, w, sh, 0, 0, w, sh);
      const img = new Image();
      img.src = off.toDataURL('image/png');
      drawings.appendChild(img);
      const rect = pad.getBoundingClientRect();
      ctx.clearRect(0,0, rect.width, rect.height);
      dirty = false;
      board.focus();
    }

    toggleDraw.addEventListener('click', () => {
      // Save whatever is there first
      saveDrawingIfAny();
      drawActive = !drawActive;
      toggleDraw.textContent = drawActive ? 'Draw: On' : 'Draw: Off';
      toggleDraw.setAttribute('aria-pressed', String(drawActive));
      document.body.classList.toggle('drawing-active', drawActive);
      if (drawActive) {
        board.blur();
        sizeCanvas();
      } else {
        board.focus();
      }
    });

    pad.addEventListener('touchstart', (e) => { if(!drawActive) return; e.preventDefault(); const p=getPoint(e); startDraw(p.x, p.y); });
    pad.addEventListener('touchmove',  (e) => { if(!drawActive) return; e.preventDefault(); const p=getPoint(e); moveDraw(p.x, p.y); });
    pad.addEventListener('touchend',   (e) => { if(!drawActive) return; e.preventDefault(); endDraw(); });
    pad.addEventListener('mousedown', (e) => { if(!drawActive) return; const p=getPoint(e); startDraw(p.x, p.y); });
    pad.addEventListener('mousemove', (e) => { if(!drawActive) return; const p=getPoint(e); moveDraw(p.x, p.y); });
    pad.addEventListener('mouseup', endDraw);
    pad.addEventListener('mouseleave', endDraw);
    window.addEventListener('resize', sizeCanvas);
  </script>
</body>
</html>
